<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>API Security Checklist</title>
      <link href="/2018/08/30/API-Security-Checklist/"/>
      <url>/2018/08/30/API-Security-Checklist/</url>
      <content type="html"><![CDATA[<p>以下是当你在设计, 测试以及发布你的 API 的时候所需要核对的重要安全措施.</p><hr><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><ul><li>不要使用 <code>Basic Auth</code> 使用标准的认证协议 (如 JWT, OAuth).</li><li>不要再造 <code>Authentication</code>, <code>token generating</code>, <code>password storing</code> 这些轮子, 使用标准的.</li><li>在登录中使用 <code>Max Retry</code> 和自动封禁功能.</li><li><p>加密所有的敏感数据.</p><a id="more"></a><h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a>JWT (JSON Web Token)</h4></li><li><p>使用随机复杂的密钥 (<code>JWT Secret</code>) 以增加暴力破解的难度.</p></li><li>不要在请求体中直接提取数据, 要对数据进行加密 (<code>HS256</code> 或 <code>RS256</code>).</li><li>使 token 的过期时间尽量的短 (<code>TTL</code>, <code>RTTL</code>).</li><li>不要在 JWT 的请求体中存放敏感数据, 它是<a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener">可破解的</a>.</li></ul><h4 id="OAuth-授权或认证协议"><a href="#OAuth-授权或认证协议" class="headerlink" title="OAuth 授权或认证协议"></a>OAuth 授权或认证协议</h4><ul><li>始终在后台验证 <code>redirect_uri</code>, 只允许白名单的 URL.</li><li>每次交换令牌的时候不要加 token (不允许 <code>response_type=token</code>).</li><li>使用 <code>state</code> 参数并填充随机的哈希数来防止跨站请求伪造(CSRF).</li><li>对不同的应用分别定义默认的作用域和各自有效的作用域参数.</li></ul><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ul><li>限制流量来防止 DDoS 攻击和暴力攻击.</li><li>在服务端使用 HTTPS 协议来防止 MITM 攻击.</li><li>使用 <code>HSTS</code> 协议防止 SSLStrip 攻击.</li></ul><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul><li>使用与操作相符的 HTTP 操作函数, <code>GET (读取)</code>, <code>POST (创建)</code>, <code>PUT (替换/更新)</code> 以及 <code>DELETE (删除记录)</code>, 如果请求的方法不适用于请求的资源则返回 <code>405 Method Not Allowed</code>.</li><li>在请求头中的 <code>content-type</code> 字段使用内容验证来只允许支持的格式 (如 <code>application/xml</code>, <code>application/json</code> 等等) 并在不满足条件的时候返回 <code>406 Not Acceptable</code>.</li><li>验证 <code>content-type</code> 的发布数据和你收到的一样 (如 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code> 等等).</li><li>验证用户输入来避免一些普通的易受攻击缺陷 (如 <code>XSS</code>, <code>SQL-注入</code>, <code>远程代码执行</code> 等等).</li><li>不要在 URL 中使用任何敏感的数据 (<code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>, or <code>API keys</code>), 而是使用标准的认证请求头.</li><li>使用一个 API Gateway 服务来启用缓存、访问速率限制 (如 <code>Quota</code>, <code>Spike Arrest</code>, <code>Concurrent Rate Limit</code>) 以及动态地部署 APIs resources.</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ul><li>检查是否所有的终端都在身份认证之后, 以避免被破坏了的认证体系.</li><li>避免使用特有的资源 id. 使用 <code>/me/orders</code> 替代 <code>/user/654321/orders</code></li><li>使用 <code>UUID</code> 代替自增长的 id.</li><li>如果需要解析 XML 文件, 确保实体解析(entity parsing)是关闭的以避免 <code>XXE</code> 攻击.</li><li>如果需要解析 XML 文件, 确保实体扩展(entity expansion)是关闭的以避免通过指数实体扩展攻击实现的 <code>Billion Laughs/XML bomb</code>.</li><li>在文件上传中使用 CDN.</li><li>如果需要处理大量的数据, 使用 Workers 和 Queues 来快速响应, 从而避免 HTTP 阻塞.</li><li>不要忘了把 DEBUG 模式关掉.</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul><li>发送 <code>X-Content-Type-Options: nosniff</code> 头.</li><li>发送 <code>X-Frame-Options: deny</code> 头.</li><li>发送 <code>Content-Security-Policy: default-src &#39;none&#39;</code> 头.</li><li>删除指纹头 - <code>X-Powered-By</code>, <code>Server</code>, <code>X-AspNet-Version</code> 等等.</li><li>在响应中强制使用 <code>content-type</code>, 如果你的类型是 <code>application/json</code> 那么你的 <code>content-type</code> 就是 <code>application/json</code>.</li><li>不要返回敏感的数据, 如 <code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>.</li><li>在操作结束时返回恰当的状态码. (如 <code>200 OK</code>, <code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>405 Method Not Allowed</code> 等等).</li></ul><h3 id="持续集成和持续部署"><a href="#持续集成和持续部署" class="headerlink" title="持续集成和持续部署"></a>持续集成和持续部署</h3><ul><li>使用单元测试和集成测试来审计你的设计和实现.</li><li>引入代码审查流程, 不要自行批准更改.</li><li>在推送到生产环境之前确保服务的所有组件都用杀毒软件静态地扫描过, 包括第三方库和其它依赖.</li><li>为部署设计一个回滚方案.</li></ul><p><a href="https://github.com/shieldfy/API-Security-Checklist/blob/master/README.md" target="_blank" rel="noopener">转自: API_Security_checklist</a></p>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis使用规范</title>
      <link href="/2018/08/29/Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2018/08/29/Redis%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h4 id="一-【推荐】冷热数据分离，不要将所有数据全部都放到Redis中"><a href="#一-【推荐】冷热数据分离，不要将所有数据全部都放到Redis中" class="headerlink" title="一. 【推荐】冷热数据分离，不要将所有数据全部都放到Redis中"></a>一. 【推荐】冷热数据分离，不要将所有数据全部都放到Redis中</h4><p>建议根据业务只将高频热数据存储到Redis中【QPS大于5000】，对于低频冷数据可以使用Mysql/ElasticSearch等基于磁盘的存储方式，不仅节省内存成本，而且数据量小在操作时速度更快、效率更高！</p><h4 id="二-【推荐】不同的业务数据要分开存储"><a href="#二-【推荐】不同的业务数据要分开存储" class="headerlink" title="二.  【推荐】不同的业务数据要分开存储"></a>二.  【推荐】不同的业务数据要分开存储</h4><p>Redis默认是提供了32个DataBase来使用，以自然数来做区分，如果不选择DataBase，都会默认使用0这个库。<br>推荐一个部门一个DataBase，然后再做NameSpace的隔离，该操作需要有SDK的支持，一个DataBase可以设置多个NameSpace，这样可以便于管理且方便清理</p><a id="more"></a><h4 id="三-【强制】规范Key的格式"><a href="#三-【强制】规范Key的格式" class="headerlink" title="三. 【强制】规范Key的格式"></a>三. 【强制】规范Key的格式</h4><p>合适的key，便于查看，统计，排错。<br>比如:</p><table><thead><tr><th>平台名</th><th>平台缩写</th></tr></thead><tbody><tr><td>呼叫中心</td><td>cc</td></tr></tbody></table><p>“平台缩写“+“-”+“项目名”+“-”+“业务含义”<br>例如：cc-scheduler-userid</p><h4 id="四-【强制】存储的Key一定要设置超时时间"><a href="#四-【强制】存储的Key一定要设置超时时间" class="headerlink" title="四  【强制】存储的Key一定要设置超时时间"></a>四  【强制】存储的Key一定要设置超时时间</h4><p><strong>Redis定位为缓存Cache使用，对于存放的Key一定要设置超时时间！</strong><br>​        <em>因为若不设置，这些Key会一直占用内存不释放，造成极大的浪费，而且随着时间的推移会导致内存占用越来越大，直到达到服务器内存上限！</em><br>​        <em>另外Key的超时长短要根据业务综合评估，而不是越长越好！(某些业务要求key长期有效。可以在每次写入时，都设置超时时间，让超时时间顺延。)</em></p><h4 id="五-【强制】对于必须要存储的大文本数据一定要压缩后存储"><a href="#五-【强制】对于必须要存储的大文本数据一定要压缩后存储" class="headerlink" title="五.【强制】对于必须要存储的大文本数据一定要压缩后存储"></a>五.【强制】对于必须要存储的大文本数据一定要压缩后存储</h4><p>对于大文本【超过500字节】写入到Redis时，一定要压缩后存储！大文本数据存入Redis，除了带来极大的内存占用外，<br>在访问量高时，很容易就会将网卡流量占满，进而造成整个服务器上的所有服务不可用，并引发雪崩效应，造成各个系统瘫痪！</p><h4 id="六-【强制】线上Redis禁止使用Keys正则匹配操作"><a href="#六-【强制】线上Redis禁止使用Keys正则匹配操作" class="headerlink" title="六.【强制】线上Redis禁止使用Keys正则匹配操作"></a>六.【强制】线上Redis禁止使用Keys正则匹配操作</h4><p>Redis是单线程处理，在线上KEY数量较多时，操作效率极低【时间复杂度为O(N)】，该命令一旦执行会严重阻塞线上其它命令的正常请求，<br>而且在高QPS情况下会直接造成Redis服务崩溃！如果有类似需求，请使用scan命令代替！</p><h4 id="七-【推荐】谨慎全量操作Hash、Set等集合结构"><a href="#七-【推荐】谨慎全量操作Hash、Set等集合结构" class="headerlink" title="七.【推荐】谨慎全量操作Hash、Set等集合结构"></a>七.【推荐】谨慎全量操作Hash、Set等集合结构</h4><p>在使用HASH结构存储对象属性时，开始只有有限的十几个field，往往使用HGETALL获取所有成员，效率也很高，但是随着业务发展，会将field扩张到上百个甚至几百个，<br>此时还使用HGETALL会出现效率急剧下降、网卡频繁打满等问题【时间复杂度O(N)】,此时建议根据业务拆分为多个Hash结构；<br>或者如果大部分都是获取所有属性的操作,可以将所有属性序列化为一个STRING类型存储！同样在使用SMEMBERS操作SET结构类型时也是相同的情况！</p><h4 id="八-【推荐】根据业务场景合理使用不同的数据结构类型"><a href="#八-【推荐】根据业务场景合理使用不同的数据结构类型" class="headerlink" title="八 .【推荐】根据业务场景合理使用不同的数据结构类型"></a>八 .【推荐】根据业务场景合理使用不同的数据结构类型</h4><p>目前Redis支持的数据库结构类型较多：字符串（String），哈希（Hash），列表（List），集合（Set），有序集合（Sorted Set）, Bitmap, HyperLogLog和地理空间索引（geospatial）等,<br>需要根据业务场景选择合适的类型，常见的如：String可以用作普通的K-V、计数类；Hash可以用作对象等，包含较多属性的信息；List可以用作消息队列、粉丝/关注列表等；Set可以用于推荐；<br>Sorted Set可以用于排行等！</p><h4 id="九-【推荐】考虑Redis的sharding机制"><a href="#九-【推荐】考虑Redis的sharding机制" class="headerlink" title="九 .【推荐】考虑Redis的sharding机制"></a>九 .【推荐】考虑Redis的sharding机制</h4><p>目前spring-data-redis的JedisConnectionFactory没有实现sharding的功能，但是其依赖Jedis实现了，所以如果要sharding，需要自己实现逻辑，需要自己去实现封装</p><h4 id="十-【推荐】对重要的数据使用try-catch"><a href="#十-【推荐】对重要的数据使用try-catch" class="headerlink" title="十 .【推荐】对重要的数据使用try/catch"></a>十 .【推荐】对重要的数据使用try/catch</h4><p>如果必须确保关键性的数据可以被放入到 Redis 的实例中，我强烈建议将其放入 try/except 块中。几乎所有的Redis客户端采用的都是“发送即忘”策略，<br>因此经常需要考虑一个 key 是否真正被放到 Redis 数据库中了。至于将 try/expect 放到 Redis 命令中的复杂性并不是本文要讲的，你只需要知道这样做可以确保重要的数据放到该放的地方就可以了。</p><h4 id="十一-【推荐】合理使用Hash"><a href="#十一-【推荐】合理使用Hash" class="headerlink" title="十一 .【推荐】合理使用Hash"></a>十一 .【推荐】合理使用Hash</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET foo first_name &quot;Warren&quot;</span><br><span class="line">127.0.0.1:6379&gt; HSET foo last_name &quot;Tom&quot;</span><br><span class="line">127.0.0.1:6379&gt; HSET foo address &quot;No.1 tech Road&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL foo</span><br><span class="line">  &quot;first_name&quot;</span><br><span class="line">  &quot;Warren&quot;</span><br><span class="line">  &quot;last_name&quot;</span><br><span class="line">  &quot;Tom&quot;</span><br><span class="line">  &quot;address&quot;</span><br><span class="line">  &quot;No.1 tech Road&quot; </span><br><span class="line">127.0.0.1:6379&gt; HGET foo last_name</span><br><span class="line">  &quot;Tom&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Running gitlab with Docker</title>
      <link href="/2018/08/23/Running-gitlab-with-Docker/"/>
      <url>/2018/08/23/Running-gitlab-with-Docker/</url>
      <content type="html"><![CDATA[<h2 id="Running-Gitlab-with-Docker"><a href="#Running-Gitlab-with-Docker" class="headerlink" title="Running Gitlab with Docker"></a>Running Gitlab with Docker</h2><h4 id="the-contents-of-docker-compose-yml"><a href="#the-contents-of-docker-compose-yml" class="headerlink" title="the contents of docker-compose.yml"></a>the contents of docker-compose.yml</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn/redis:latest</span><br><span class="line">    command:</span><br><span class="line">    - --loglevel warning</span><br><span class="line">    volumes:</span><br><span class="line">    - /data/gitlab_data/redis:/var/lib/redis:Z</span><br><span class="line"></span><br><span class="line">  postgresql:</span><br><span class="line">    restart: always</span><br><span class="line">    image: sameersbn/postgresql:<span class="number">9.6</span>-<span class="number">2</span></span><br><span class="line">    volumes:</span><br><span class="line">    - /data/gitlab_data/postgresql:/var/lib/postgresql:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DB_USER=gitlab</span><br><span class="line">    - DB_PASS=JKv+NP4S_E</span><br><span class="line">    - DB_NAME=gitlabhq</span><br><span class="line">    - DB_EXTENSION=pg_trgm</span><br><span class="line"></span><br><span class="line">  gitlab:</span><br><span class="line">    restart: always</span><br><span class="line">    #image: sameersbn/gitlab:9.2.2</span><br><span class="line">    #image: sameersbn/gitlab:10.7.2</span><br><span class="line">    image: sameersbn/gitlab:<span class="number">11.1</span>.4</span><br><span class="line">    depends_on:</span><br><span class="line">    - redis</span><br><span class="line">    - postgresql</span><br><span class="line">    ports:</span><br><span class="line">    - <span class="string">"80:80"</span></span><br><span class="line">    - <span class="string">"22:22"</span></span><br><span class="line">    volumes:</span><br><span class="line">    - /data/gitlab_data/gitlab:/home/git/data:Z</span><br><span class="line">    environment:</span><br><span class="line">    - DEBUG=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    - DB_ADAPTER=postgresql</span><br><span class="line">    - DB_HOST=postgresql</span><br><span class="line">    - DB_PORT=<span class="number">5432</span></span><br><span class="line">    - DB_USER=gitlab</span><br><span class="line">    - DB_PASS=JKv+NP4S_E</span><br><span class="line">    - DB_NAME=gitlabhq</span><br><span class="line"></span><br><span class="line">    - REDIS_HOST=redis</span><br><span class="line">    - REDIS_PORT=<span class="number">6379</span></span><br><span class="line"></span><br><span class="line">    - TZ=Asia/Shanghai</span><br><span class="line">    - GITLAB_TIMEZONE=Beijing</span><br><span class="line"></span><br><span class="line">    - GITLAB_HTTPS=<span class="keyword">false</span></span><br><span class="line">    - SSL_SELF_SIGNED=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    - GITLAB_HOST=YOUR_FQDN</span><br><span class="line">    - GITLAB_PORT=<span class="number">80</span></span><br><span class="line">    - GITLAB_SSH_PORT=<span class="number">22</span></span><br><span class="line">    - GITLAB_RELATIVE_URL_ROOT=</span><br><span class="line">    - GITLAB_SECRETS_DB_KEY_BASE=VCXvWzzkxbNwjwXFb3dX49T3rL9jvrtrrbzrqgW4qmbVgpcWLnkgbNfwbdfwP9Wn</span><br><span class="line">    - GITLAB_SECRETS_SECRET_KEY_BASE=KsXDBZkRlRxfFlcdPxP43wnxQWG53B6lKJnzQS3PFmrR96ccdnRtxcDBSQW7D2PP</span><br><span class="line">    - GITLAB_SECRETS_OTP_KEY_BASE=mWh7McVTxJBCVC8jCC9RNB3gpTFpPMhmSL3MLc62WSHdgnJZKdPRWZg7PXKHKqrs</span><br><span class="line">    - GITLAB_SIGNUP_ENABLED=<span class="keyword">false</span></span><br><span class="line">    - GITLAB_ROOT_PASSWORD=YOUR_PASSWORD_HERE</span><br><span class="line">    - GITLAB_ROOT_EMAIL=admin@<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line"></span><br><span class="line">    - GITLAB_CREATE_GROUP=<span class="keyword">false</span></span><br><span class="line">    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=<span class="keyword">true</span></span><br><span class="line">    - GITLAB_NOTIFY_PUSHER=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">    - GITLAB_EMAIL=admin@<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - GITLAB_EMAIL_DISPLAY_NAME=Gitlab</span><br><span class="line">    - GITLAB_EMAIL_REPLY_TO=admin@<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - GITLAB_INCOMING_EMAIL_ADDRESS=USER+%&#123;key&#125;<span class="meta">@ziyitong</span>.com.cn</span><br><span class="line"></span><br><span class="line">    - GITLAB_BACKUP_SCHEDULE=daily</span><br><span class="line">    - GITLAB_BACKUP_TIME=<span class="number">04</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line">    - SMTP_ENABLED=<span class="keyword">true</span></span><br><span class="line">    - SMTP_DOMAIN=<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - SMTP_HOST=smtp.1byte.vip</span><br><span class="line">    - SMTP_PORT=<span class="number">25</span></span><br><span class="line">    - SMTP_USER=admin@<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - SMTP_PASS=YOUR_EMAIL_PASS_HERE</span><br><span class="line">    - SMTP_STARTTLS=<span class="keyword">true</span></span><br><span class="line">    - SMTP_AUTHENTICATION=login</span><br><span class="line"></span><br><span class="line">    - IMAP_ENABLED=<span class="keyword">false</span></span><br><span class="line">    - IMAP_HOST=mail.1byte.vip</span><br><span class="line">    - IMAP_PORT=<span class="number">993</span></span><br><span class="line">    - IMAP_USER=admin@<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - IMAP_PASS=YOUR_EMAIL_PASS_HERE</span><br><span class="line">    - IMAP_SSL=<span class="keyword">false</span></span><br><span class="line">    - LDAP_ENABLED=<span class="keyword">true</span></span><br><span class="line">    - LDAP_LABEL=LDAP</span><br><span class="line">    - LDAP_HOST=<span class="number">1</span><span class="keyword">byte</span>.vip</span><br><span class="line">    - LDAP_PORT=<span class="number">3268</span></span><br><span class="line">    - LDAP_UID=sAMAccountName</span><br><span class="line">    - LDAP_METHOD=plain</span><br><span class="line">    - LDAP_BIND_DN=CN=admin,OU=warren,DC=<span class="number">1</span><span class="keyword">byte</span>,DC=vip</span><br><span class="line">    - LDAP_PASS=AD_PASS</span><br><span class="line">    - LDAP_TIMEOUT=<span class="number">10</span></span><br><span class="line">    - LDAP_BASE=OU=warren,DC=<span class="number">1</span><span class="keyword">byte</span>,DC=vip</span><br><span class="line">    - LDAP_ACTIVE_DIRECTORY=<span class="keyword">true</span></span><br><span class="line">    - LDAP_ALLOW_USERNAME_OR_EMAIL_LOGIN=<span class="keyword">true</span></span><br><span class="line">    - LDAP_LOCK_AUTO_CREATED_USERS=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="starting-gitlab-service"><a href="#starting-gitlab-service" class="headerlink" title="starting gitlab service"></a>starting gitlab service</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links"></a>Reference Links</h4><p><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">docker installation docs</a><br><a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">docker-compose CLI </a><br><a href="https://github.com/sameersbn/docker-gitlab/blob/master/README.md" target="_blank" rel="noopener">doc of sameersbn/gitlab </a></p>]]></content>
      
      
        <tags>
            
            <tag> CI_CD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Semantic Versioning</title>
      <link href="/2018/08/23/Semantic-Versioning/"/>
      <url>/2018/08/23/Semantic-Versioning/</url>
      <content type="html"><![CDATA[<h2 id="语义化版本-2-0-0"><a href="#语义化版本-2-0-0" class="headerlink" title="语义化版本 2.0.0"></a>语义化版本 2.0.0</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ol><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li></ol><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的套件越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p><p>在依赖高的系统中发布新版本套件可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个相依套件改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本相依被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。</p><p>作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p><p>我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p><h3 id="语义化版本控制规范（SemVer）"><a href="#语义化版本控制规范（SemVer）" class="headerlink" title="语义化版本控制规范（SemVer）"></a>语义化版本控制规范（SemVer）</h3><p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）</p><ol><li><p>使用语义化版本控制的软件“必须 MUST ”定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。</p></li><li><p>标准的版本号“必须 MUST ”采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且“禁止 MUST NOT”在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素“必须 MUST ”以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</p></li><li><p>标记版本号的软件发行后，“禁止 MUST NOT ”改变该版本软件的内容。任何修改都“必须 MUST ”以新版本发行。</p></li><li><p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</p></li><li><p>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</p></li><li><p>修订号 Z（x.y.Z <code>|</code> x &gt; 0）“必须 MUST ”在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</p></li><li><p>次版本号 Y（x.Y.z <code>|</code> x &gt; 0）“必须 MUST ”在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也“必须 MUST ”递增。也“可以 MAY ”在内部程序有大量新功能或改进被加入时递增，其中“可以 MAY ”包括修订级别的改变。每当次版本号递增时，修订号“必须 MUST ”归零。</p></li><li><p>主版本号 X（X.y.z <code>|</code> X &gt; 0）“必须 MUST ”在有任何不兼容的修改被加入公共 API 时递增。其中“可以 MAY ”包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号“必须 MUST ”归零。</p></li><li><p>先行版本号“可以 MAY ”被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须 MUST ”由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且“禁止 MUST NOT ”留白。数字型的标识符号“禁止 MUST NOT ”在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</p></li><li><p>版本编译信息“可以 MAY ”被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号“必须 MUST ”由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且“禁止 MUST NOT ”留白。当判断版本的优先层级时，版本编译信息“可 SHOULD ”被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</p></li><li><p>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，“必须 MUST ”把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级“必须 MUST ”透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0。</p></li></ol><h3 id="为什么要使用语义化的版本控制？"><a href="#为什么要使用语义化的版本控制？" class="headerlink" title="为什么要使用语义化的版本控制？"></a>为什么要使用语义化的版本控制？</h3><p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p><p>举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的套件。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定相依于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的套件管理系统，因为它们能与原有相依的软件兼容。</p><p>作为一位负责任的开发者，你理当确保每次套件升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级套件，而无需推出新的相依套件，节省你的时间及烦恼。</p><p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="在-0-y-z-初始开发阶段，我该如何进行版本控制？"><a href="#在-0-y-z-初始开发阶段，我该如何进行版本控制？" class="headerlink" title="在 0.y.z 初始开发阶段，我该如何进行版本控制？"></a>在 0.y.z 初始开发阶段，我该如何进行版本控制？</h4><p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p><h4 id="如何判断发布-1-0-0-版本的时机？"><a href="#如何判断发布-1-0-0-版本的时机？" class="headerlink" title="如何判断发布 1.0.0 版本的时机？"></a>如何判断发布 1.0.0 版本的时机？</h4><p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p><h4 id="这不会阻碍快速开发和迭代吗？"><a href="#这不会阻碍快速开发和迭代吗？" class="headerlink" title="这不会阻碍快速开发和迭代吗？"></a>这不会阻碍快速开发和迭代吗？</h4><p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p><h4 id="对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？"><a href="#对于公共-API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到-42-0-0-版？" class="headerlink" title="对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？"></a>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</h4><p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p><h4 id="为整个公共-API-写文件太费事了！"><a href="#为整个公共-API-写文件太费事了！" class="headerlink" title="为整个公共 API 写文件太费事了！"></a>为整个公共 API 写文件太费事了！</h4><p>为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p><h4 id="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"><a href="#万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？" class="headerlink" title="万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？"></a>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</h4><p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p><h4 id="如果我更新了自己的依赖但没有改变公共-API-该怎么办？"><a href="#如果我更新了自己的依赖但没有改变公共-API-该怎么办？" class="headerlink" title="如果我更新了自己的依赖但没有改变公共 API 该怎么办？"></a>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</h4><p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的套件有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p><h4 id="如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"><a href="#如果我变更了公共-API-但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）" class="headerlink" title="如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）"></a>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</h4><p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p><h4 id="我该如何处理即将弃用的功能？"><a href="#我该如何处理即将弃用的功能？" class="headerlink" title="我该如何处理即将弃用的功能？"></a>我该如何处理即将弃用的功能？</h4><p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p><h4 id="语义化版本对于版本的字串长度是否有限制呢？"><a href="#语义化版本对于版本的字串长度是否有限制呢？" class="headerlink" title="语义化版本对于版本的字串长度是否有限制呢？"></a>语义化版本对于版本的字串长度是否有限制呢？</h4><p>没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。</p><p><a href="https://semver.org" target="_blank" rel="noopener">Semantic Versioning 2.0.0</a></p>]]></content>
      
      
        <tags>
            
            <tag> CI_CD </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
